


#include <s3c44b0x.h>
#include <s3cev40.h>
#include <common_types.h>
#include <system.h>
#include <leds.h>
#include <segs.h>
#include <uart.h>
#include <rtc.h>
#include <timers.h>
#include <pbs.h>
#include <keypad.h>
#include <lcd.h>
#include <ts.h>

#include "kernelcoop.h"

/////////////////////////////////////////////////////////////////////////////
// CONFIGURACION
/////////////////////////////////////////////////////////////////////////////

#define MAXPLACES               (10)

// Periodos de iniciación de tareas y otros (ms)

#define TS_SCAN_TASK_MS         (50)
#define KEYPAD_SCAN_TASK_MS     (50)
#define PBS_TASK_MS             (50)
#define CLOCK_TASK_MS         (1000)
#define PROCESS_COINS_TASK_MS  (100)
#define MAIN_TASK_MS           (100)  
#define REPORT_TASK_MS        (1000)
#define PRINT_TICKET_TASK_MS  (1000)

/////////////////////////////////////////////////////////////////////////////
// Declaracion de tipos
/////////////////////////////////////////////////////////////////////////////

typedef struct
{
    uint8 hour;
    uint8 min;
} hour_t;

typedef struct
{
    boolean active;
    hour_t  start;
    hour_t  end;
} opHours_t;

typedef struct
{
    boolean    occupied;
    rtc_time_t start;
    rtc_time_t end;
} place_t;

typedef struct
{
    uint8     numPlaces;
    uint16    centMin;
    uint16    minMin;
    uint16    minMax;
    uint8     coins[4];
    opHours_t opHours[7]; 
    place_t   places[MAXPLACES];
    uint32    money;    
} parking_t;

/////////////////////////////////////////////////////////////////////////////
// Declaracion de funciones
/////////////////////////////////////////////////////////////////////////////

void setup( void );
void plotWelcomeScreen( void );

/////////////////////////////////////////////////////////////////////////////
// Declaracion de tareas
/////////////////////////////////////////////////////////////////////////////

void tsScanTask( void );
void keypadScanTask( void );
void clockTask( void );
void processCoinsTask( void );
void pbsScanTask( void );
void mainTask( void );
void printTicketTask( void );

/////////////////////////////////////////////////////////////////////////////
// Declaracion de recursos
/////////////////////////////////////////////////////////////////////////////

parking_t parking;

struct mbox1 {
	boolean flag;
	uint8   cents;
} coinAcceptorMsg;

struct mbox2 {
	boolean flag;
	uint16  x, y;
} tsPressedMsg;

struct mbox3 {
	boolean flag;
	boolean accept;
} coinRedirectMsg;

boolean printTicketFlag;

/*******************************************************************/

void main( void )
{
    
    sys_init();      
    leds_init();
    segs_init();
    uart0_init();
    rtc_init();
    timers_init();
    pbs_init();
    keypad_init();
    lcd_init();
    ts_init();

    lcd_on();
    ts_on();

    setup();

    scheduler_init();                         /* Inicializa el kernel */

    create_task( tsScanTask,       5   );     /* Crea las tareas de la aplicación... */
    create_task( keypadScanTask,   5   );     /* ... el kernel asigna la prioridad según orden de creación: Task2 > Task5 > Task6 > ... */
    create_task( pbsScanTask,      5   );     /* ... las tareas más frecuentes tienen mayor prioridad (criterio Rate-Monotonic-Scheduling) */
    create_task( mainTask,         10  );      
    create_task( processCoinsTask, 10  );
    create_task( clockTask,        10  );
    create_task( printTicketTask,  10  );

    timer0_open_tick( scheduler, TICKS_PER_SEC );  /* Instala scheduler como RTI del timer0  */

    while( 1 )
    {
        sleep();                /* Entra en estado IDLE, sale por interrupción */
        dispacher();            /* Las tareas preparadas se ejecutan en esta hebra (background) en orden de prioridad */
    }

}

/*******************************************************************/

/* 
** Tarea principal, se activa cada 100 ms muestreando los mensajes enviados de otras tareas y actuando en consecuencia  
*/
void mainTask( void )  
{
    static boolean init = TRUE;
    static enum { waiting, demoAcceptCoins } state;
    static uint16 credit;
    static uint16 count;

    if( init )
    {
        init   = FALSE;
		plotWelcomeScreen();
		credit = 0;
        state = waiting;
    }
    else switch( state )
    {
        case waiting:
            if( tsPressed.flag ) 
            {
                tsPressed.flag = FALSE;
                lcd_clear();
                state = demoAcceptCoins;
                count = 1000;
            }    
            if( coinAcceptorMsg.flag )
            {
                coinAcceptorMsg.flag   = FALSE;
                coinRedirectMsg.accept = FALSE;
                coinRedirectMsg.flag   = TRUE;
            }    
            break;
        case demoAcceptCoins:
            if( !(--count) )
            {
                plotWelcomeScreen();
                state = waiting;
            }
            if( tsPressed.flag ) 
            {
                tsPressed.flag = FALSE;                
                coinRedirectMsg.accept = TRUE;
                coinRedirectMsg.flag   = TRUE;
                credit = 0;
                plotWelcomeScreen();
                state = waiting;				
            }    
            if( coinAcceptorMsg.flag )
            {
                coinAcceptorMsg.flag   = FALSE;
				credit += coinValue;
				lcd_putint_x2( 24, 48, BLACK, credit );
				count = 1000;
            }
            break;
    }
}

/* 
** Cada segundo muestrea si ha recibido un mensaje de la tarea principal para imprimir a través de la UART el ticket del aparcamiento elegido
*/
void printTicketTask( void )
{
   
}

/* 
** Cada segundo visualiza la fecha/hora en la pantalla y libera aquellas plazas cuya hora de finalización haya pasado
*/
void clockTask( void )  
{

}
/* 
** Cada 50 ms muestrea la touchscreen y envía un mensaje a la tarea principal con la posición del lugar pulsado
*/
void tsScanTask( void )  
{
    static boolean init = TRUE;
    static enum { wait_keydown, scan, wait_keyup } state;
    
    if( init )
    {
        init  = FALSE;
        state = wait_keydown;
    }
    else switch( state )
    {
        case wait_keydown:
            if( ts_pressed() )
                state = scan;
            break;
        case scan:
            ts_getpos( &tsPressedMsg.x, &tsPressedMsg.y );
            tsPressedMsg.flag = TRUE;
            state = wait_keyup;
            break;
        case wait_keyup:
            if( !ts_pressed() )
                state = wait_keydown;
            break;
    }
}

/* 
** Emula el comportamiento de un reconocedor de monedas:
** Cada 50 ms muestrea el keypad y envía un mensaje a la tarea principal con el valor de la moneda introducida
*/
void keypadScanTask( void )  
{
    static boolean init = TRUE;
    static enum { wait_keydown, scan, wait_keyup } state;
    
    if( init )
    {
        init  = FALSE;
        state = wait_keydown;
    }
    else switch( state )
    {
        case wait_keydown:
            if( keypad_pressed() )
                state = scan;
            break;
        case scan:
            switch( keypad_scan() )
            {
                case KEYPAD_KEYF:
                    coinAcceptorMsg.cents = 10;
                    coinAcceptorMsg.flag  = TRUE;
                    break;                
            }
            state = wait_keyup;
            break;
        case wait_keyup:
            if( !keypad_pressed() )
                state = wait_keydown;
            break;
    }    
}  


/* 
** Emula el comportamiento del dispositivo que envía las monedas a la alcancía o al cajetin de devolución 
** Cada 100 ms muestrea si ha recibido un mensaje de la tarea principal para activar durante 1 s los leds y los 7-segmentos
*/
void processCoinsTask( void ) 
{
    static boolean init = TRUE;
    static enum { off, on } state;    
    static uint32 count;
    
    if( init )
    {
        init  = FALSE;
        state = off;
    }
    else switch( state )
    {
        case off:
            if( coinRedirectMsg.flag )
            {
                coinRedirectMsg.flag = FALSE;
                if( coinRedirectMsg.accept )
                    segs_putchar( 0xA );
                else
                    segs_putchar( 0xD );
                led_on( LEFT_LED );
                led_on( RIGHT_LED );  
                state = on;
				count = 10;				
            }
            break;
        case on:
            if( !(--count) )
            {  
                segs_off();
                led_off( LEFT_LED );
                led_off( RIGHT_LED );                                
                state = off;
            }
            break;
    }
}    

/*******************************************************************/

/* 
** Inicializa flags, mailboxes y variables globales
*/
void setup( void )
{
	coinAcceptorMsg.flag  = FALSE;
	coinAcceptorMsg.cents = 0;
	
	tsPressedMsg.flag = FALSE;
	tsPressedMsg.x   = 0;
	tsPressedMsg,y   = 0;

	coinRedirectMsg.flag   = FALSE;
	coinRedirectMsg.accept = FALSE;
	
    printTicketFlag  = FALSE;
}


void plotWelcomeScreen( void )
{   
    lcd_clear();
    lcd_puts_x2( 24, 48,  BLACK,   "Pulse la pantalla" );
    lcd_puts_x2( 24, 76, BLACK, "  para comenzar  " );
    plotSchedule( 132 );
}
