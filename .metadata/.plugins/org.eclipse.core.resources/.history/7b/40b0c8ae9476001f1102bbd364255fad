


#include <s3c44b0x.h>
#include <s3cev40.h>
#include <common_types.h>
#include <system.h>
#include <leds.h>
#include <segs.h>
#include <uart.h>
#include <rtc.h>
#include <timers.h>
#include <keypad.h>
#include <lcd.h>
#include <ts.h>

#include "kernelcoop.h"

/////////////////////////////////////////////////////////////////////////////
// CONFIGURACION
/////////////////////////////////////////////////////////////////////////////

#define MAXPLACES              (10)

// Periodos de iniciaci√≥n de tareas y otros (ms)

#define TS_SCAN_TASK_MS        (50)
#define KEYPAD_SCAN_TASK_MS    (50)
#define CLOCK_TASK_MS        (1000)
#define COINS_MOVE_TASK_MS    (100)
#define MAIN_TASK_MS          (100)  
#define REPORT_TASK_MS       (1000)
#define PRINT_TICKET_TASK_MS (1000)

/////////////////////////////////////////////////////////////////////////////
// Declaracion de tipos
/////////////////////////////////////////////////////////////////////////////

typedef struct
{
    uint8 hour;
    uint8 min;
} hour_t;

typedef struct
{
    boolean active;
    hour_t  start;
    hour_t  end;
} opHours_t;

typedef struct
{
    boolean    occupied;
    rtc_time_t start;
    rtc_time_t end;
} place_t;

typedef struct
{
    uint8     numPlaces;
    uint16    centMin;
    uint16    minMin;
    uint16    minMax;
    uint8     coins[4];
    opHours_t opHours[7]; 
    place_t   places[MAXPLACES];
    uint32    money;    
} parking_t;

/////////////////////////////////////////////////////////////////////////////
// Declaracion de funciones
/////////////////////////////////////////////////////////////////////////////

void setup( void );
void plotWelcomeScreen( void );

/////////////////////////////////////////////////////////////////////////////
// Declaracion de tareas
/////////////////////////////////////////////////////////////////////////////

void tsScanTask( void );
void coinsAcceptorTask( void );
void clockTask( void );
void coinsMoverTask( void );
void mainTask( void );
void ticketPrintTask( void );

/////////////////////////////////////////////////////////////////////////////
// Declaracion de recursos
/////////////////////////////////////////////////////////////////////////////

parking_t parking;

struct mbox1 {
	boolean flag;
	uint8   cents;
} coinAcceptorMsg;

struct mbox2 {
	boolean flag;
	uint16  x, y;
} tsPressedMsg;

struct mbox3 {
	boolean flag;
	boolean accept;
} coinsMoverMsg;

boolean printTicketFlag;

/*******************************************************************/

void main( void )
{
    
    sys_init();      
    leds_init();
    segs_init();
    uart0_init();
    rtc_init();
    timers_init();
    keypad_init();
    lcd_init();
    ts_init();

    lcd_on();
    ts_on();

    setup();

    scheduler_init();                       /* Inicializa el kernel */

    create_task( tsScanTask,        5 );    /* Crea las tareas de la aplicacion... */
    create_task( coinsAcceptorTask, 5 );    /* ... el kernel asigna la prioridad segun orden de creacion */
    create_task( mainTask,         10 );    /* ... las tareas mas frecuentes tienen mayor prioridad (criterio Rate-Monotonic-Scheduling) */
    create_task( coinsMoverTask,   10 );
    create_task( clockTask,        10 );
    create_task( ticketPrintTask,  10 );

    timer0_open_tick( scheduler, TICKS_PER_SEC );  /* Instala scheduler como RTI del timer0  */

    while( 1 )
    {
        sleep();                /* Entra en estado IDLE, sale por interrupcion */
        dispacher();            /* Las tareas preparadas se ejecutan en esta hebra (background) en orden de prioridad */
    }

}

/*******************************************************************/

/* 
** Tarea principal, se activa cada 100 ms muestreando los mensajes enviados de otras tareas y actuando en consecuencia  
*/
void mainTask( void )  
{
    static boolean init = TRUE;
    static enum { demoWaiting, demoAcceptCoins } state;
    static uint16 credit;
    static uint16 ticks;

    if( init )
    {
        init   = FALSE;
		plotWelcomeScreen();
		credit = 0;
        state = demoWaiting;
    }
    else switch( state )
    {
        case demoWaiting:						/* Estado esperando la presion de la pantalla */
            if( tsPressedMsg.flag )				/* Chequea si se ha pulsado la pantalla (mensaje recibido de la tarea tsPressedTask) */
            {
                tsPressedMsg.flag = FALSE;		/* Marca el mensaje como leido */
                lcd_clear();					/* Borra pantalla */
                state = demoAcceptCoins;		/* Salta al estado demoAcceptCoins ... */
                ticks = 500;					/* ... en el que debera permanecer un maximo de 500 ticks */
            }    
            if( coinAcceptorMsg.flag )			/* Chequea si se ha introducido una moneda (mensaje recibido de la tarea coinAcceptorTask) */
            {
                coinAcceptorMsg.flag = FALSE;	/* Marca el mensaje como leido */
                coinsMoverMsg.accept = FALSE;   /* Envia un mensaje para que la moneda se devuelva */
                coinsMoverMsg.flag   = TRUE;
            }    
            break;
        case demoAcceptCoins:
            if( !(--ticks) )
            {
                plotWelcomeScreen();
                state = demoWaiting;
            }
            if( tsPressedMsg.flag )
            {
                tsPressedMsg.flag = FALSE;
                coinsMoverMsg.accept = TRUE;
                coinsMoverMsg.flag   = TRUE;
                credit = 0;
                plotWelcomeScreen();
                state = demoWaiting;
            }    
            if( coinAcceptorMsg.flag )
            {
                coinAcceptorMsg.flag   = FALSE;
				credit += coinAcceptorMsg.cents;
				lcd_putint_x2( 24, 48, BLACK, credit );
				ticks = 500;
            }
            break;
    }
}

/* 
** Cada segundo muestrea si ha recibido un mensaje de la tarea principal para imprimir a traves de la UART el ticket del aparcamiento elegido
*/
void ticketPrintTask( void )
{
   
}

/* 
** Cada segundo visualiza la fecha/hora en la pantalla y libera aquellas plazas cuya hora de finalizacion haya pasado
*/
void clockTask( void )  
{

}
/* 
** Cada 50 ms muestrea la touchscreen y envia un mensaje a la tarea principal con la posicion del lugar pulsado
*/
void tsScanTask( void )  
{
    static boolean init = TRUE;
    static enum { wait_keydown, scan, wait_keyup } state;
    
    if( init )
    {
        init  = FALSE;
        state = wait_keydown;
    }
    else switch( state )
    {
        case wait_keydown:						/* Estado esperando la presion de la pantalla */
            if( ts_pressed() )						/* Chequea la pantalla esta presionada */
                state = scan;						/* Salta al estado scan */
            break;
        case scan:                              /* Estado en que escanea la pantalla */
            ts_getpos( &tsPressedMsg.x, &tsPressedMsg.y );	/* Lee la pantalla */
            tsPressedMsg.flag = TRUE;				/* Envia un mensaje con el valor de la posicion presionada */
            state = wait_keyup;						/* Salta al estado wait_keyup */
            break;
        case wait_keyup:						/* Estado esperando la depresion de la pantalla  */
            if( !ts_pressed() )						/* Chequea si la pantalla ya no esta presionada */
                state = wait_keydown;				/* Salta al estado wait_keydown */
            break;
    }
}

/* 
** Emula el comportamiento de un reconocedor de monedas:
**   Cada 50 ms muestrea el keypad y envia un mensaje a la tarea principal con el valor de la moneda asociada a la tecla
*/
void coinsAcceptorTask( void )  
{
    static boolean init = TRUE;
    static enum { wait_keydown, scan, wait_keyup } state;
    
    if( init )
    {
        init  = FALSE;
        state = wait_keydown;
    }
    else switch( state )
    {
        case wait_keydown:						/* Estado esperando la presion teclas */
            if( keypad_pressed() )					/* Chequea si hay una tecla presionada */
                state = scan;						/* Salta al estado scan */
            break;
        case scan:                              /* Estado en que escanea el teclado */
            switch( keypad_scan() )					/* Lee el teclado */
            {
                case KEYPAD_KEYF:					/* La tecla F esta asociada a la moneda de 0,10 euros */
                    coinAcceptorMsg.cents = 10;		/* Envia un mensaje con el valor de la moneda */
                    coinAcceptorMsg.flag  = TRUE;
                    break;                
            }
            state = wait_keyup;						/* Salta al estado wait_keyup */
            break;
        case wait_keyup:						/* Estado esperando la depresion de teclas  */
            if( !keypad_pressed() )					/* Chequea si la tecla ya no esta presionada */
                state = wait_keydown;				/* Salta al estado wait_keydown */
            break;
    }    
}  

/* 
** Emula el comportamiento del dispositivo que envia las monedas a la alcancia o al cajetin de devolucion:
**   Cada 100 ms muestrea si ha recibido un mensaje de la tarea principal para mover monedas
**   Si van a la alcancia activa durante 1 s los leds y muestra una A en los segs
**   Si van al cajetin de devolucion activa durante 1 segundo los leds y muestra una D en los segs
*/
void coinsMoverTask( void ) 
{
    static boolean init = TRUE;
    static enum { off, on } state;    
    static uint32 ticks;
    
    if( init )
    {
        init  = FALSE;
        state = off;
    }
    else switch( state )
    {
        case off:								/* Estado con leds y 7-segs apagados */
            if( coinsMoverMsg.flag )				/* Chequea si ha recibido mensaje */
            {
                coinsMoverMsg.flag = FALSE;			/* Marca el mensaje como leido */
                if( coinsMoverMsg.accept )          /* Muestra el mensaje que corresponda en segs */
                    segs_putchar( 0xA );
                else
                    segs_putchar( 0xD );
                led_on( LEFT_LED );					/* Enciende leds */
                led_on( RIGHT_LED );
                state = on;							/* Salta al estado on ... */
                ticks = 10;							/* ... en el que debera permanecer 10 ticks */
            }
            break;
        case on:								/* Estado con leds y 7-segs encendidos */
            if( !(--ticks) )						/* Decrementa ticks y chequea si ha permanecido en este estado el tiempo requerido */
            {  
                segs_off();							/* Apaga segs */
                led_off( LEFT_LED );				/* Apaga leds */
                led_off( RIGHT_LED );                                
                state = off;						/* Salta al estado off */
            }
            break;
    }
}    

/*******************************************************************/

/* 
** Inicializa flags, mailboxes y variables globales
*/
void setup( void )
{
	coinAcceptorMsg.flag  = FALSE;
	coinAcceptorMsg.cents = 0;
	
	tsPressedMsg.flag     = FALSE;
	tsPressedMsg.x        = 0;
	tsPressedMsg.y        = 0;

	coinsMoverMsg.flag    = FALSE;
	coinsMoverMsg.accept  = FALSE;
	
    printTicketFlag       = FALSE;
}


void plotWelcomeScreen( void )
{   
    lcd_clear();
    lcd_puts_x2( 24, 48, BLACK, "Pulse la pantalla" );
    lcd_puts_x2( 24, 76, BLACK, "  para comenzar  " );
}
